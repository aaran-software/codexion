got it — we’ll **keep Postgres**. here’s a tight, numbered TODO for refinement (prioritized). I’ve pointed each item at the exact spots in code that drive the change.

# TODO — Refinement Plan (with priorities)

1. **Enable Postgres end-to-end (P0)**

   * Allow `DB_ENGINE="postgres"` in settings (extend the Literal)&#x20;
   * Un-comment/register Postgres in the dialect registry so it’s actually discoverable&#x20;
   * Sanity-check PG placeholder translation `%s → $1,$2,…` (already implemented)&#x20;

2. **Make the schema builder truly cross-DB (P0)**

   * Refactor `TableBlueprint` to be **dialect-aware**:

     * Use `d.quote_ident(name)` for all column/index/constraint identifiers (no hardcoded backticks)&#x20;
     * Replace MySQL-isms:

       * `id()` → use PG: `GENERATED BY DEFAULT AS IDENTITY`, MySQL: `INT AUTO_INCREMENT`, SQLite: `INTEGER PRIMARY KEY AUTOINCREMENT` (today it’s hardcoded MySQL)&#x20;
       * `timestamps()` → drop `ON UPDATE CURRENT_TIMESTAMP` for PG/SQLite; keep only default now/current for those (MySQL keeps “on update”)&#x20;
       * `unique()` → emit `CONSTRAINT name UNIQUE (...)` on PG; current `UNIQUE KEY` is MySQL-specific&#x20;
       * `index()` inside CREATE TABLE is fine on MySQL, but **not** on PG → collect and create after table for PG via `createIndex()`&#x20;
       * `enum()` → map to PG `CHECK (...)` (you already partly do that for MySQL via `ENUM(...)`)&#x20;
       * Boolean defaults: emit `TRUE/FALSE` on PG (currently `'1'/'0'`)&#x20;

3. **Teach `builder.create()` to post-create indexes where needed (P0)**

   * Detect dialect; for PG/SQLite, strip inline `INDEX ...` from the CREATE and issue `createIndex()` calls afterwards (works because `createIndex()` already supports PG’s `IF NOT EXISTS`)

4. **Fix service provider wiring (P0)**

   * Re-enable `DatabaseProvider` and `MigrationProvider` in `PROVIDERS` so `migrator` binds and doctor checks reflect reality (they’re commented now)&#x20;

5. **Unify engine import path (P0)**

   * `bootstrap.py` imports `prefiq.database.connection.get_engine` while the rest of DB code uses `connection_manager.get_engine`. Standardize on one (recommended: `connection_manager`)&#x20;

6. **PG-safe drop path (P1)**

   * In `drop_all()`, add optional `CASCADE` for PG to avoid FK dependency errors; keep plain `DROP TABLE IF EXISTS` for MySQL/SQLite&#x20;

7. **Migrations table creation survives PG (P1)**

   * `_ensure_migrations_table()` currently uses `t.index(...)` + `t.unique(...)`. Ensure #2/#3 changes make this succeed on PG (index after create; `UNIQUE` syntax switch)&#x20;

8. **Loader cleanup + resilience (P1)**

   * Remove unused `configparser` import&#x20;
   * Add fallback: if `migration_order.json` missing, scan `apps/<app>/database/migration/*.py` in alpha order (current behavior is hard fail/skip)&#x20;

9. **Settings polish for PG (P1)**

   * When `DB_ENGINE=postgres`, default `DB_PORT=5432` (you can keep 3306 for MySQL/MariaDB) — optional QoL tweak.&#x20;

10. **JSON/UUID/ENUM types per dialect (P1)**

    * `json()` → PG: `JSONB`, MySQL: `JSON`, SQLite: `TEXT` (or keep JSON if driver maps)&#x20;
    * `uuid()` → PG: `UUID`, MySQL: `CHAR(36)` (current), SQLite: `TEXT`&#x20;
    * `enum()` → already emits CHECK name option (augment for PG)&#x20;

11. **Dialect-aware boolean defaults (P1)**

    * Update `_format_default()` to output `TRUE/FALSE` on PG; keep `1/0` for MySQL; SQLite accepts `1/0`.&#x20;

12. **Doctor commands UX (P1)**

    * Ensure `prefiq doctor database --strict` fails if DB provider not present (wired in CLI), and prints the DSN/driver for PG path as well. (CLI hook exists.)&#x20;

13. **Runner: async hygiene (P2)**

    * `_await()` uses `asyncio.run()` which is fine for CLI; guard against “already running loop” if embedding under an ASGI server later.&#x20;

14. **Logging filters (P2)**

    * Keep the filter that hides the boilerplate migrations-table SQL; verify it still triggers after builder changes.&#x20;

15. **Test matrix (P2)**

    * Smoke tests for SQLite/MySQL/MariaDB/Postgres: create/drop, inline vs post-create indexes, enum/json/uuid defaults, boolean defaults, timestamps behavior. (Covers items 2–11.)

---

if you want, I can start by doing **(1) + (2) + (3) + (4)** right now — those unlock Postgres cleanly and keep MySQL/SQLite working.
