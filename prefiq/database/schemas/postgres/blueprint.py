from __future__ import annotations
from typing import List, Optional, Tuple, Dict

_SQL_KEYWORDS_NOQUOTE = {
    "CURRENT_TIMESTAMP", "CURRENT_DATE", "CURRENT_TIME",
    "LOCALTIME", "LOCALTIMESTAMP", "NOW()",
}

def q(name: str) -> str:
    # Postgres standard: double-quoted identifiers
    return f"\"{name}\""


class TableBlueprint:
    """
    Postgres flavor:
    - Double quotes for identifiers.
    - Uses BIGSERIAL for id() convenience (simple primary key).
    - Records index metadata for separate creation after CREATE TABLE.
    - Allows t.index('col'), t.index(['a','b']) OR t.index('idx_name', ['a','b']).
    """
    def __init__(self, table_name: str):
        self.table_name = table_name
        self.columns: List[str] = []
        self.foreign_keys: List[str] = []
        self.unique_constraints: List[str] = []
        self.check_constraints: List[str] = []
        self._index_meta: List[Tuple[str, List[str]]] = []
        self._pending_fks: List[Dict[str, Optional[str | Tuple[str, str]]]] = []

    # ── internal helpers ────────────────────────────────────────────────────

    def _column_definition(self, name: str, type_def: str, *, nullable=True, default=None, unique=False) -> str:
        col = f"{q(name)} {type_def}"
        if not nullable:
            col += " NOT NULL"
        if default is not None:
            col += f" DEFAULT {self._format_default(default)}"
        if unique:
            col += " UNIQUE"
        return col

    def _format_default(self, default):
        if isinstance(default, str):
            up = default.upper()
            if up in _SQL_KEYWORDS_NOQUOTE:
                return up
            return f"'{default}'"
        if isinstance(default, bool):
            return "TRUE" if default else "FALSE"
        return str(default)

    # ── column builders ─────────────────────────────────────────────────────

    def id(self, name: str = "id"):
        # simple/portable choice; if you prefer identity: use "GENERATED BY DEFAULT AS IDENTITY"
        self.columns.append(f"{q(name)} BIGSERIAL PRIMARY KEY")

    def string(self, name: str, length: int = 255, **kwargs):
        self.columns.append(self._column_definition(name, f"VARCHAR({length})", **kwargs))

    def text(self, name: str, **kwargs):        self.columns.append(self._column_definition(name, "TEXT", **kwargs))
    def longtext(self, name: str, **kwargs):     self.columns.append(self._column_definition(name, "TEXT", **kwargs))
    def tinytext(self, name: str, **kwargs):     self.columns.append(self._column_definition(name, "TEXT", **kwargs))
    def blob(self, name: str, **kwargs):         self.columns.append(self._column_definition(name, "BYTEA", **kwargs))
    def tiny_integer(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "SMALLINT", **kwargs))
    def integer(self, name: str, **kwargs):      self.columns.append(self._column_definition(name, "INTEGER", **kwargs))
    def biginteger(self, name: str, **kwargs):   self.columns.append(self._column_definition(name, "BIGINT", **kwargs))
    def boolean(self, name: str, **kwargs):      self.columns.append(self._column_definition(name, "BOOLEAN", **kwargs))
    def datetime(self, name: str, **kwargs):     self.columns.append(self._column_definition(name, "TIMESTAMP", **kwargs))
    def date(self, name: str, **kwargs):         self.columns.append(self._column_definition(name, "DATE", **kwargs))
    def json(self, name: str, **kwargs):         self.columns.append(self._column_definition(name, "JSONB", **kwargs))
    def uuid(self, name: str, **kwargs):         self.columns.append(self._column_definition(name, "UUID", **kwargs))

    def enum(self, name: str, values: List[str], constraint_name: Optional[str] = None, **kwargs):
        # generic, inline CHECK (no global TYPE setup)
        self.columns.append(self._column_definition(name, "TEXT", **kwargs))
        enum_values = ", ".join(f"'{v}'" for v in values)
        cname = q(constraint_name) if constraint_name else ""
        self.check_constraints.append(
            f"{'CONSTRAINT ' + cname + ' ' if cname else ''}CHECK ({q(name)} IN ({enum_values}))"
        )

    def check(self, condition: str, name: Optional[str] = None):
        if name:
            self.check_constraints.append(f"CONSTRAINT {q(name)} CHECK ({condition})")
        else:
            self.check_constraints.append(f"CHECK ({condition})")

    # ── indexes (flexible signature) ────────────────────────────────────────

    def index(self, a, b=None):
        """
        Usage:
            t.index("col")                         -> auto name: idx_<table>_col
            t.index(["col1","col2"])               -> auto name: idx_<table>_col1_col2
            t.index("idx_custom", ["col"])         -> explicit name
        """
        if b is None:
            # a is columns (str or list[str])
            cols = [c.strip() for c in (a if isinstance(a, list) else [a])]
            idx_name = self._auto_index_name(cols)
        else:
            idx_name = str(a)
            cols = [c.strip() for c in (b if isinstance(b, list) else [b])]
        self._index_meta.append((idx_name, cols))

    def unique(self, name: str, columns: List[str]):
        cols = ", ".join(q(c) for c in columns)
        self.unique_constraints.append(f"CONSTRAINT {q(name)} UNIQUE ({cols})")

    # ── foreign keys (deferred assembly) ────────────────────────────────────

    def foreign_id(self, name: str):
        self.columns.append(f"{q(name)} BIGINT")
        self._pending_fks.append({"column": name, "references": None, "on_delete": None, "on_update": None})
        return self

    def references(self, ref_table: str, ref_column: str = "id"):
        if self._pending_fks:
            self._pending_fks[-1]["references"] = (ref_table, ref_column)
        return self

    def on_delete(self, action: str):
        if self._pending_fks: self._pending_fks[-1]["on_delete"] = action
        return self

    def on_update(self, action: str):
        if self._pending_fks: self._pending_fks[-1]["on_update"] = action
        return self

    def _finalize_foreign_keys(self):
        for fk in self._pending_fks:
            if fk["references"]:
                col = fk["column"]; ref_table, ref_column = fk["references"]
                clause = f"FOREIGN KEY ({q(col)}) REFERENCES {q(ref_table)}({q(ref_column)})"
                if fk["on_delete"]: clause += f" ON DELETE {fk['on_delete']}"
                if fk["on_update"]: clause += f" ON UPDATE {fk['on_update']}"
                self.foreign_keys.append(clause)
        self._pending_fks.clear()

    # ── timestamp helpers ───────────────────────────────────────────────────

    def timestamps(self):
        # NOTE: Postgres does not auto-update updated_at without a trigger; app code should update it.
        self.columns.append(f"{q('created_at')} TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
        self.columns.append(f"{q('updated_at')} TIMESTAMP DEFAULT CURRENT_TIMESTAMP")

    def soft_deletes(self, column_name: str = "deleted_at"):
        self.columns.append(f"{q(column_name)} TIMESTAMP NULL")

    # ── build & expose metadata ─────────────────────────────────────────────

    def build_columns(self) -> str:
        self._finalize_foreign_keys()
        all_defs = self.columns + self.foreign_keys + self.check_constraints + self.unique_constraints
        return ",\n  ".join(all_defs)

    @property
    def index_meta(self) -> List[Tuple[str, List[str]]]:
        return list(self._index_meta)

    # ── helpers ─────────────────────────────────────────────────────────────

    def _auto_index_name(self, cols: List[str]) -> str:
        # keep simple; caller can override with explicit name if needed
        safe_cols = "_".join(c.replace('"', "").replace(" ", "_") for c in cols)
        return f"idx_{self.table_name}_{safe_cols}"
