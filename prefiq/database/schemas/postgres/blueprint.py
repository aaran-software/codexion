# prefiq/database/schemas/postgres/blueprint.py
from __future__ import annotations
from typing import List, Optional, Tuple, Dict

_SQL_KEYWORDS_NOQUOTE = {
    "CURRENT_TIMESTAMP", "CURRENT_DATE", "CURRENT_TIME", "LOCALTIME", "LOCALTIMESTAMP",
    "NOW()",  # acceptable as function in PG
}

def q(name: str) -> str:
    return f"\"{name}\""

class TableBlueprint:
    """
    Postgres flavor: double quotes, IDENTITY, JSONB/UUID, no inline indexes, CONSTRAINT UNIQUE.
    """
    def __init__(self, table_name: str):
        self.table_name = table_name
        self.columns: List[str] = []
        self.foreign_keys: List[str] = []
        self.unique_constraints: List[str] = []
        self.check_constraints: List[str] = []
        self._index_meta: List[Tuple[str, List[str]]] = []
        self._pending_fks: List[Dict[str, Optional[str | Tuple[str, str]]]] = []

    def _column_definition(self, name: str, type_def: str, nullable=True, default=None, unique=False) -> str:
        col = f"{q(name)} {type_def}"
        if not nullable:
            col += " NOT NULL"
        if default is not None:
            col += f" DEFAULT {self._format_default(default)}"
        if unique:
            col += " UNIQUE"
        return col

    def _format_default(self, default):
        if isinstance(default, str):
            up = default.upper()
            if up in _SQL_KEYWORDS_NOQUOTE:
                return up
            return f"'{default}'"
        if isinstance(default, bool):
            return 'TRUE' if default else 'FALSE'
        return str(default)

    # columns
    def id(self, name: str = "id"):
        self.columns.append(f"{q(name)} BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY")

    def string(self, name: str, length: int = 255, **kwargs): self.columns.append(self._column_definition(name, f"VARCHAR({length})", **kwargs))
    def text(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "TEXT", **kwargs))
    def longtext(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "TEXT", **kwargs))
    def tinytext(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "TEXT", **kwargs))
    def blob(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "BYTEA", **kwargs))
    def tiny_integer(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "SMALLINT", **kwargs))
    def integer(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "INTEGER", **kwargs))
    def biginteger(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "BIGINT", **kwargs))
    def boolean(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "BOOLEAN", **kwargs))
    def datetime(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "TIMESTAMP WITHOUT TIME ZONE", **kwargs))
    def date(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "DATE", **kwargs))
    def json(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "JSONB", **kwargs))
    def uuid(self, name: str, **kwargs): self.columns.append(self._column_definition(name, "UUID", **kwargs))

    def enum(self, name: str, values: List[str], constraint_name: Optional[str] = None, **kwargs):
        # Use CHECK constraint by default (no CREATE TYPE)
        self.columns.append(self._column_definition(name, "TEXT", **kwargs))
        enum_values = ", ".join(f"'{v}'" for v in values)
        cname = q(constraint_name) if constraint_name else ""
        self.check_constraints.append(f"{'CONSTRAINT ' + cname + ' ' if cname else ''}CHECK ({q(name)} IN ({enum_values}))")

    def check(self, condition: str, name: Optional[str] = None):
        if name: self.check_constraints.append(f"CONSTRAINT {q(name)} CHECK ({condition})")
        else: self.check_constraints.append(f"CHECK ({condition})")

    def index(self, name: str, column: str | List[str]):
        cols = [c.strip() for c in (column if isinstance(column, list) else [column])]
        self._index_meta.append((name, cols))

    def unique(self, name: str, columns: List[str]):
        cols = ", ".join(q(c) for c in columns)
        self.unique_constraints.append(f"CONSTRAINT {q(name)} UNIQUE ({cols})")

    def foreign_id(self, name: str):
        self.columns.append(f"{q(name)} BIGINT")
        self._pending_fks.append({"column": name, "references": None, "on_delete": None, "on_update": None})
        return self

    def references(self, ref_table: str, ref_column: str = "id"):
        if self._pending_fks: self._pending_fks[-1]["references"] = (ref_table, ref_column)
        return self

    def on_delete(self, action: str):
        if self._pending_fks: self._pending_fks[-1]["on_delete"] = action
        return self

    def on_update(self, action: str):
        if self._pending_fks: self._pending_fks[-1]["on_update"] = action
        return self

    def _finalize_foreign_keys(self):
        for fk in self._pending_fks:
            if fk["references"]:
                col = fk["column"]; ref_table, ref_column = fk["references"]
                clause = f"FOREIGN KEY ({q(col)}) REFERENCES {q(ref_table)}({q(ref_column)})"
                if fk["on_delete"]: clause += f" ON DELETE {fk['on_delete']}"
                if fk["on_update"]: clause += f" ON UPDATE {fk['on_update']}"
                self.foreign_keys.append(clause)
        self._pending_fks.clear()

    def timestamps(self):
        self.columns.append(f"{q('created_at')} TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP")
        self.columns.append(f"{q('updated_at')} TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP")

    def soft_deletes(self, column_name: str = "deleted_at"):
        self.columns.append(f"{q(column_name)} TIMESTAMP WITHOUT TIME ZONE NULL")

    def build_columns(self) -> str:
        self._finalize_foreign_keys()
        all_defs = self.columns + self.foreign_keys + self.check_constraints + self.unique_constraints
        return ",\n  ".join(all_defs)

    @property
    def index_meta(self) -> List[Tuple[str, List[str]]]:
        return list(self._index_meta)
